using Antlr4.Runtime;
using System;
using System.IO;
using System.Linq;
using System.Text;

namespace ANTLRTest
{
    public class Program
    {
        public static void Main(string[] args)
        {
            var fileName = "../../../input.vex";
            var filePath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, fileName);

            if (!File.Exists(filePath))
            {
                Console.WriteLine($"Error: Input file not found at '{filePath}'");
                return;
            }

            var fileContent = File.ReadAllText(filePath);
            var inputStream = new AntlrInputStream(fileContent);
            var lexer = new ANTLRTest.CompilerLexer(inputStream);

            // Attach lexer error listener
            var errorReporter = new ErrorReporter();
            lexer.RemoveErrorListeners();
            lexer.AddErrorListener((IAntlrErrorListener<int>)errorReporter);

            var commonTokenStream = new CommonTokenStream(lexer);

            SaveTokensToFile(commonTokenStream, "../../../tokens.txt");
            commonTokenStream.Seek(0);

            var parser = new CompilerParser(commonTokenStream);

            // Attach parser error listener
            parser.RemoveErrorListeners();
            parser.AddErrorListener(errorReporter);

            var context = parser.program();

            // Write any lexer/parser errors to file
            if (errorReporter.Errors.Count > 0)
            {
                File.WriteAllLines("../../../errors.txt", errorReporter.Errors);
                Console.WriteLine($"Errors detected. See '../../../errors.txt' for details.");
            }

            var visitor = new EvalVisitor();
            visitor.Evaluate(context);

            // Collect semantic errors from visitor and write to errors file in addition
            var semanticErrors = visitor.SemanticErrors;
            if (semanticErrors.Count > 0)
            {
                var allErrors = errorReporter.Errors.Concat(semanticErrors).ToList();
                File.WriteAllLines("../../../errors.txt", allErrors);
                Console.WriteLine($"Semantic errors detected. See '../../../errors.txt' for details.");
            }

            SaveGlobalVariablesToFile(visitor, "../../../global_variables.txt");

            // Analyze and save function information
            var functionAnalyzer = new FunctionAnalyzer();
            var functions = functionAnalyzer.Analyze(context);
            FunctionAnalyzer.WriteToFile(functions, "../../../functions.txt");
            Console.WriteLine($"Function analysis saved to 'functions.txt'");

            Console.WriteLine("Parsing completed.");
            Console.WriteLine("\nParse Tree:");
            Console.WriteLine(PrettyPrintTree(context.ToStringTree(parser)));

            Console.WriteLine("\nVariables:");
            var variables = visitor.Variables;
            foreach (var kvp in variables)
            {
                Console.WriteLine($"  {kvp.Key} = {kvp.Value.Value} (Type: {kvp.Value.Type}, Scope: {kvp.Value.Scope})");
            }

            // Print function summary to console
            Console.WriteLine("\nFunctions:");
            foreach (var func in functions)
            {
                var funcType = func.IsRecursive ? "Recursive" : "Iterative";
                var mainType = func.IsMain ? "Main" : "Non-Main";
                Console.WriteLine($"  {func.Name}: {funcType}, {mainType}, Returns: {func.ReturnType}, Params: {func.Parameters.Count}, LocalVars: {func.LocalVariables.Count}, ControlStructures: {func.ControlStructures.Count}");
            }
        }

        private static void SaveGlobalVariablesToFile(EvalVisitor visitor, string outputPath)
        {
            var globalVars = visitor.Variables
                .Where(kvp => kvp.Value.Scope == "global")
                .Select(kvp => $"Variable: {kvp.Key}, Type: {kvp.Value.Type}, Initial Value: {kvp.Value.Value}");

            File.WriteAllLines(outputPath, globalVars);
            Console.WriteLine($"Global variables saved to '{outputPath}'");
        }

        private static void SaveTokensToFile(CommonTokenStream tokens, string outputPath)
        {
            tokens.Fill();
            var tokenTuples = tokens.GetTokens().Select(t =>
            {
                string tokenName = CompilerLexer.DefaultVocabulary.GetSymbolicName(t.Type) ?? "EOF";
                string lexem = t.Text.Replace("\r", "\\r").Replace("\n", "\\n");
                int lineIndex = t.Line;
                return $"<{tokenName}, {lexem}, {lineIndex}>";
            });
            File.WriteAllLines(outputPath, tokenTuples);
            Console.WriteLine($"Tokens saved to '{outputPath}'");
        }

        private static string PrettyPrintTree(string tree)
        {
            var sb = new StringBuilder();
            int indentLevel = 0;
            const string indent = "  ";
            for (int i = 0; i < tree.Length; i++)
            {
                char c = tree[i];
                if (c == '(')
                {
                    if (i > 0 && tree[i - 1] != '(' && tree[i - 1] != ' ')
                    {
                        sb.AppendLine();
                        sb.Append(string.Concat(Enumerable.Repeat(indent, indentLevel)));
                    }
                    sb.Append(c);
                    indentLevel++;
                    sb.AppendLine();
                    sb.Append(string.Concat(Enumerable.Repeat(indent, indentLevel)));
                }
                else if (c == ')')
                {
                    indentLevel--;
                    sb.AppendLine();
                    sb.Append(string.Concat(Enumerable.Repeat(indent, indentLevel)));
                    sb.Append(c);
                }
                else if (c == ' ' && i + 1 < tree.Length && tree[i + 1] == '(')
                {
                    // Skip space before opening paren
                }
                else
                {
                    sb.Append(c);
                }
            }
            return sb.ToString();
        }
    }
}